<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<script>

    // 链式调用，三次网络请求
    // new Promise((resolve, reject)=>{
    //     // setTimeout理解为一次请求
    //     setTimeout(()=>{
    //         let data = '0'
    //         console.log('第一次请求获得结果:',data);
    //         // 成功后
    //         resolve(data)
    //         // 失败后
    //         // reject('err')
    //     }, 3000)
    // }).then((data)=>{
    //     // 将数据处理一下，以用于第二次请求
    //     data += '1'
    //     return new Promise((resolve, reject) => {
    //         setTimeout(()=>{
    //             console.log('第二次请求获得结果:',data);
    //             // 成功后
    //             resolve(data)
    //             // 失败后
    //             // reject('err')
    //         }, 3000)
    //     })
    // }).then(data=>{
    //     // 将第二次请求得到的数据处理一下，以用于第三次请求
    //     data += '2'
    //     return new Promise((resolve, reject) => {
    //         setTimeout(()=>{
    //             console.log('第三次请求获得结果:',data);
    //             // 成功后
    //             resolve(data)
    //             // 失败后
    //             // reject('err')
    //         }, 3000)
    //     })
    // }).then(data=>{
    //     // 处理第三次请求的结果
    //     data += '3'
    //     console.log(data);
    //     // 完成
    // }).catch(err=>{
    //     // 中间有一次reject，都会直接到这里
    //     // 或者抛出错误，throw ""
    //     console.log(err)
    // })



    // 也是一步一步处理，但是每一步处理中没有异步操作【第一种写法】
    // new Promise((resolve, reject)=>{
    //     setTimeout(()=>{
    //         console.log('获得结果:0');
    //         resolve('0')
    //     }, 1000)
    // }).then((data)=>{
    //     // 第一次处理数据
    //     data += '1'
    //     console.log(data)
    //     return new Promise(resolve => {
    //         // 没有异步操作，理解为进行下一步处理
    //         resolve(data)
    //     })
    // }).then(data=>{
    //     // 第二次处理数据
    //     data += '2'
    //     console.log(data)
    //     return new Promise(resolve => {
    //         // 没有异步操作，理解为再进行下一步操作
    //         resolve(data)
    //     })
    // }).then(data=>{
    //     // 第三次处理数据
    //     data += '3'
    //     console.log(data);
    //     // 处理完成
    // })




    // 也是一步一步处理，但是每一步处理中没有异步操作【第二种写法】
    // new Promise((resolve, reject)=>{
    //     setTimeout(()=>{
    //         console.log('获得结果:0');
    //         resolve('0')
    //     }, 1000)
    // }).then((data)=>{
    //     // 第一次处理数据
    //     data += '1'
    //     console.log(data)
    //     // 【提供了一个API，简介写写法】
    //     return Promise.resolve(data)
    // }).then(data=>{
    //     // 第二次处理数据
    //     data += '2'
    //     console.log(data)
    //     // 【提供了一个API，简介写写法】
    //     return Promise.resolve(data)
    // }).then(data=>{
    //     // 第三次处理数据
    //     data += '3'
    //     console.log(data);
    //     // 处理完成
    // })



    // 也是一步一步处理，但是每一步处理中没有异步操作【第三种写法】
    new Promise((resolve, reject)=>{
        setTimeout(()=>{
            console.log('获得结果:0');
            resolve('0')
        }, 1000)
    }).then((data)=>{
        // 第一次处理数据
        data += '1'
        console.log(data)
        // 【内部会进行promise封装，内部会调用resolve】
        return data
    }).then(data=>{
        // 第二次处理数据
        data += '2'
        console.log(data)
        // 【内部会进行promise封装，内部会调用resolve】
        return data
    }).then(data=>{
        // 第三次处理数据
        data += '3'
        console.log(data);
        // 处理完成
    })


    // reject的简写可以是 Promise.reject(err),也是没有异步操作的时候
    // 另一种写法：throw '异常信息'。catch会捕捉异常

</script>
</body>
</html>